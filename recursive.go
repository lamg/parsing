package parsing

import (
	"errors"
	"fmt"
	"io"
)

// Tree is the abstract syntax tree generated by the parser
type Tree struct {
	Value    string
	Token    *Token
	Children []*Tree
}

// Symbol is the data structure representing the grammar
// to be parsed
type Symbol struct {
	Name       string
	IsTerminal bool
	IsEmpty    bool
	Next       *Symbol
	Alt        *Symbol
	Header     *Symbol
}

// Parse parses the grammar in g using the tokens in tks
func Parse(g *Symbol, tks TokenStream) (t *Tree, e error) {
	tks.Next()
	t, e = parse(g, tks)
	if e == nil {
		tk, err := tks.Current()
		if err == nil {
			t, e = nil, &RemainingTokenErr{Token: tk}
		}
	}
	if errors.Is(e, io.EOF) {
		e = nil
	}
	return
}

func parse(g *Symbol, tks TokenStream) (t *Tree, e error) {
	curr, parsed, match := g, []*Tree{}, false
	for curr != nil {
		var nt *Tree
		if curr.IsTerminal {
			nt, e = matchTk(tks, curr)
		} else {
			nt, e = parse(curr.Header, tks)
		}
		match = nt != nil
		if match {
			if nt.Value != Empty.Name {
				parsed = append(parsed, nt)
			}
			curr = curr.Next
		} else {
			curr = curr.Alt
		}
	}
	if match {
		t = build(parsed, g)
	}
	return
}

func build(parsed []*Tree, root *Symbol) (t *Tree) {
	if !root.IsTerminal {
		t = &Tree{Value: root.Name, Children: parsed}
	} else if len(parsed) != 0 {
		t = parsed[0]
		if len(parsed) != 1 {
			t.Children = parsed[1:]
		}
	}
	return
}

func matchTk(tks TokenStream, s *Symbol) (r *Tree, e error) {
	var tk *Token
	tk, e = tks.Current()
	eof := errors.Is(e, io.EOF)
	if e == nil {
		if s.Name == tk.Name {
			r = &Tree{Value: tk.Name, Token: tk}
			tks.Next()
		} else {
			if s.IsEmpty {
				r = &Tree{Value: s.Name}
			} else {
				e = &ExpectingErr{
					Expected: s.Name,
					Actual:   tk.Name,
				}
			}
		}
	} else if eof {
		if s.IsEmpty {
			r = &Tree{Value: s.Name}
		} else {
			e = &UnexpectedEOFErr{
				Expected: s.Name,
			}
		}
	}
	return
}

// TokenStream is the interface for supplying tokens to the
// parser
type TokenStream interface {
	Current() (*Token, error)
	Next()
}

// ExpectingErr is the error signaled when an unexpected
// token is received
type ExpectingErr struct {
	Expected string
	Actual   string
}

func (x *ExpectingErr) Error() string {
	return fmt.Sprintf("Expected: %s, Actual: %s",
		x.Expected, x.Actual)
}

// UnexpectedEOFErr is the error signaled when the end of
// file is reached unexpectedly
type UnexpectedEOFErr struct {
	Expected string
}

func (x *UnexpectedEOFErr) Error() string {
	return fmt.Sprintf("Unexpected EOF, expecting '%s'", x.Expected)
}

// RemainingTokenErr is the error signaled when tokens remain
// without parsing at the end of the stream
type RemainingTokenErr struct {
	Token *Token
}

func (x *RemainingTokenErr) Error() string {
	return fmt.Sprintf("Remaining token %v", x.Token)
}

// Empty is the empty symbol used for closing loops in
// the Symbol data structure
var Empty = &Symbol{
	Name:       "âˆ…",
	IsEmpty:    true,
	IsTerminal: true,
}

func TermTree(s string) *Tree {
	return &Tree{
		Value: s,
		Token: &Token{Name: s, Value: s},
	}
}

func IdentTree(s string) *Tree {
	return &Tree{
		Value: Identifier,
		Token: &Token{Name: Identifier, Value: s},
	}
}
