package parsing

import (
	"errors"
	"fmt"
	"io"
)

// Tree is the abstract syntax tree generated by the parser
type Tree struct {
	Value    string
	Token    *Token
	Children []*Tree
}

// Symbol is the data structure representing the grammar
// to be parsed
type Symbol struct {
	Name       string
	IsTerminal bool
	IsEmpty    bool
	Next       *Symbol
	Alt        *Symbol
	Header     *Symbol
}

// Parse parses the grammar in g using the tokens in tks
func Parse(g *Symbol, tks TokenStream) (t *Tree, e error) {
	t, e = parse(g, tks)
	if e == nil {
		tk, err := tks.Current()
		if err == nil {
			e = &RemainingTokenErr{Token: tk}
		}
	}
	return
}

func parse(g *Symbol, tks TokenStream) (t *Tree, e error) {
	curr := g
	t = &Tree{Value: curr.Name}
	for curr != nil && e == nil {
		var nt *Tree
		var tk *Token
		if curr.IsTerminal {
			if !curr.IsEmpty {
				tk, e = tks.Current()
				if e == nil {
					if curr.Name == tk.Name {
						tks.Next()
					} else {
						e = &ExpectingErr{
							Expected: curr.Name,
							Actual:   tk.Name,
						}
					}
				} else if errors.Is(e, io.EOF) {
					e = &UnexpectedEOFErr{
						After: curr.Name,
					}
				}
			}
		} else {
			nt, e = parse(curr.Header, tks)
		}
		if e == nil {
			if nt != nil {
				t.Children = append(t.Children, nt)
			} else if tk != nil {
				if g.IsTerminal {
					t.Token = tk
				} else {
					t.Children = append(t.Children,
						&Tree{Value: tk.Name, Token: tk})
				}
			}
			curr = curr.Next
		} else {
			curr = curr.Alt
			var xe *ExpectingErr
			if curr != nil &&
				!(errors.As(e, &xe) && xe.Expected == SupportedToken) {
				e = nil
			}
		}
	}
	// TODO error handling
	if errors.Is(e, io.EOF) {
		e = nil
	}
	return
}

// TokenStream is the interface for supplying tokens to the
// parser
type TokenStream interface {
	Current() (*Token, error)
	Next()
}

// ExpectingErr is the error signaled when an unexpected
// token is received
type ExpectingErr struct {
	Expected string
	Actual   string
}

func (x *ExpectingErr) Error() string {
	return fmt.Sprintf("Expected: %s, Actual: %s",
		x.Expected, x.Actual)
}

// UnexpectedEOFErr is the error signaled when the end of
// file is reached unexpectedly
type UnexpectedEOFErr struct {
	After string
}

func (x *UnexpectedEOFErr) Error() string {
	return fmt.Sprintf("Unexpected EOF after '%s'", x.After)
}

// RemainingTokenErr is the error signaled when tokens remain
// without parsing at the end of the stream
type RemainingTokenErr struct {
	Token *Token
}

func (x *RemainingTokenErr) Error() string {
	return fmt.Sprintf("Remaining token %v", x.Token)
}

// Empty is the empty symbol used for closing loops in
// the Symbol data structure
var Empty = &Symbol{
	Name:       "âˆ…",
	IsEmpty:    true,
	IsTerminal: true,
}
